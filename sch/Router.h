#pragma once

#include <phy/Layout.h>
#include "Subckt.h"
#include "Placer.h"
#include <set>
#include <unordered_set>
#include <array>
#include <vector>

using namespace std;

namespace sch {

struct Router;

// This structure points to a single pin in the cell. See the Pin structure
// below.
struct Index {
	Index();
	Index(int type, int pin);
	~Index();

	// index into Subckt::stack (Model::NMOS or Model::PMOS)
	int type;

	// index into Subckt::stack[type].pins, pin number from left to right
	int pin;
};

bool operator<(const Index &i0, const Index &i1);
bool operator==(const Index &i0, const Index &i1);
bool operator!=(const Index &i0, const Index &i1);

// A Pin represents either a gate of a transistor or a source/drain connection
// (called contacts). The list of Pins in a cell is given to us by the placer.
// Pins are vertical paths through the layout, and Wires are horizontal paths
// through the layout.
struct Pin {
	Pin(const Tech &tech);
	// Construct a "contact" pin.
	Pin(const Tech &tech, int outNet);
	// Construct a "gate" pin
	Pin(const Tech &tech, int device, int outNet, int leftNet, int rightNet);
	~Pin();

	// inNet == outNet == gateNet for contacts
	// inNet and outNet represent source and drain depending on Placer::Device::flip
	// These index into Subckt::nets
	int leftNet;
	int outNet;
	int rightNet;

	// index into Subckt::mos for gates of transistors
	// equal to -1 for contacts
	int device;

	//-------------------------------
	// Layout Information
	//-------------------------------
	// This is the actual geometry for this pin. See phy/Layout.h
	// This is generated by Draw::drawPin()
	Layout layout;
	// Routing level (this is mis-named, should be "level")
	// index into Tech::wires, See phy/Tech.h
	int layer;

	// dimensions of the pin in dbunits. See phy/Tech.h
	int width;
	int height;

	// index of the pin in the opposite stack that this pin is aligned to.
	// index into Subckt::stack[1-Subckt::mos[this->device].type].pins
	int align;

	// minimum offset from other pins following spacing rules
	// <from, offset>
	// |==|==|
	//  ---->
	//  ->
	map<Index, int> toPin;
	// current absolute position, computed from off, pin alignment, via constraints
	int pos;

	// These help detect minimum spacing violations between pins and vias on
	// other wires.
	// minimum and maximum Y coordinate (vertical) to which this pin extends in
	// the current iteration of the layout
	int lo;
	int hi;

	void offsetToPin(Index pin, int value);

	bool isGate() const;
	bool isContact() const;
};

// This structure represents a via connection between a Pin and a Wire. It is
// stored in Wire::pins.
struct Contact {
	Contact(const Tech &tech);
	Contact(const Tech &tech, Index idx);
	~Contact();

	// index of the pin this contact connects to	
	Index idx;
	// the minimum and maximum X coordinate (horizontal) of this pin in the
	// layout
	int left;
	int right;

	// This is the actual geometry for this via. See phy/Layout.h
	// This is generated by Draw::drawViaStack()
	Layout layout;

	// Minimum required spacing from other pins to the left of
	// this via to this via. "from" indexes into Subckt::stack, "offset" is
	// distance in dbunits. This is computed by offsetFromPin()
	// <from, offset>
	// |==|==|
	//       O
	//  ---->
	//     ->
	map<Index, int> fromPin;

	// Minimum required spacing from other pins to the left of
	// this via to this via. "from" indexes into Subckt::stack, "offset" is
	// distance in dbunits. This is computed by offsetToPin()
	// <to, offset>
	// |==|==|
	// O
	//  ---->
	//  ->
	map<Index, int> toPin;

	void offsetFromPin(Index Pin, int value);
	void offsetToPin(Index Pin, int value);
};

bool operator<(const Contact &c0, const Contact &c1);
bool operator==(const Contact &c0, const Contact &c1);
bool operator!=(const Contact &c0, const Contact &c1);

// DESIGN(edward.bingham) use this to keep Wire::pins sorted
// This isn't a particularly integral structure in the Router or Placer. This
// is just a helper to keep the vias in Wire::pins sorted from left to right.
struct CompareIndex {
	CompareIndex(const Router *rt, bool orderIndex = true);
	~CompareIndex();

	const Router *rt;
	bool orderIndex;

	bool operator()(const Index &i0, const Index &i1);
	bool operator()(const Contact &c0, const Index &i1);
	bool operator()(const Contact &c0, const Contact &c1);
};

// This structure represents a horizontal path connecting some number of pins.
// Pins represent vertical paths connecting some number of wires. Stacks of
// transistors (pull up or pull down stacks) are also represented by this
// structure to abstract away special cases.
struct Wire {
	Wire(const Tech &tech);
	Wire(const Tech &tech, int net);
	~Wire();

	// If this positive, then this indexes into Subckt::nets
	// If this is negative, then flip(net) indexes into Subckt::stack to represent a stack.
	int net;

	// index into Subckt::stack
	// DESIGN(edward.bingham) We should always keep this array sorted based on
	// horizontal location of the pin in the cell from left to right. This helps
	// us pick pins to dogleg when breaking cycles. See CompareIndex
	vector<Contact> pins;

	// Indexes into Tech::wires, see phy/Tech.h
	// This represents the routing level (poly, local interconnect, metal 1,
	// metal 2, etc) on which the segment of this wire between two pins is
	// routed. For level[i], this is the segment between pins[i] and pins[i+1].
	// This is largely computed by lowerRoutes() in the Router.
	vector<int> level;

	// The minimum and maximum X coordinate (horizontal) of this wire in the
	// layout. This is used to choose how to break a route to fix a cycle
	int left;
	int right;

	//-------------------------------
	// Layout Information
	//-------------------------------
	// This is the actual geometry for this wire. See phy/Layout.h
	// This is generated by Draw::drawWire()
	Layout layout;

	// The layout of a cell is drawn such that the PMOS stack is on bottom and
	// the NMOS stack is on top. The coordinate system for pOffset starts from
	// the bottom edge of the PMOS stack at 0 and increases as we approach the
	// NMOS stack. The coordinate system for the nOffset starts from the top edge
	// of the NMOS stack at 0 and increases as we approach the PMOS stack. When
	// the drawing is complete at the end, we flip the geometry vertically before
	// saving it to the GDS file.

	// The vertical distance from the [NMOS,PMOS] stack to this wire.
	array<int, 2> offset;

	// This is used to detect cycles in the routing graph.
	// index into Subckt::routes
	unordered_set<int> prevNodes;

	void addPin(const Router *rt, Contact pin);
	int findPin(const Router *rt, Index pin) const;
	bool hasPin(const Router *rt, Index pin) const;
	void resortPins(const Router *rt);
	int getLevel(int i) const;
	bool hasPrev(int r) const;
	bool hasGate(const Router *rt) const;
	vector<bool> pinTypes() const;
};

// This structure keeps track of all of the pins in the pull up or pull down
// stack. It is also used to represent new vertical paths that need to be
// created to resolve cyclic dependencies in the routing graph.
struct Stack {
	Stack();
	Stack(int type);
	~Stack();

	// The type of devices in this stack.
	// Model::NMOS (0), Model::PMOS (1), or 2 for virtual pins
	int type;
	// The list of pins in this stack.
	vector<Pin> pins;
	// index into Subckt::routes. Which wire represents this stack in the
	// routing problem
	int route;
	
	void push(const Tech &tech, const Subckt &ckt, int device, bool flip);
};


// DESIGN(edward.bingham) Two opposing pins on the two stacks will
// create an ordering constraint on their associated routes.
//
//  |=|==
//  O-|--
//    O--
//  O---- 
//  | O--
//  |=|==
//
// This forces the routes associated with the pins on the lower stack
// to be below the routes associated with the pins on the upper
// stack. If a route has pins in both the upper and lower stacks,
// then it is possible for these ordering constraints to form cycles.
// These cycles must be separated by breaking up the route into two
// separate routes, thus separating the conflicting ordering
// constraints between two different routes. See Router::breakCycles
// for more information about this process.
//
// All of these constraints are directional arcs that point from a
// PMOS pin to an NMOS pin. The participating routes are determined
// in situ. This makes it more expensive to walk the constraint
// graph, but ensures that we can operate on routes without needing
// to re-index the pin constraints.
struct PinConstraint {
	PinConstraint();
	PinConstraint(int from, int to);
	~PinConstraint();

	int from; // index into Router::stack[Model::PMOS]
	int to;   // index into Router::stack[Model::NMOS]
};

bool operator==(const PinConstraint &c0, const PinConstraint &c1);
bool operator<(const PinConstraint &c0, const PinConstraint &c1);

// DESIGN(edward.bingham) The following relations between pins are
// not allowed if the three pins are too close for the via
// enclosure and via-pin spacing rules.
//
//                   |====   ====|
//                   |   O   O   |
// |=|=|    O   O    | O |   | O |
// | O |    | O |    O | |   | | O
// O   O    |=|=|    ==|=|   |=|==
//
// The remaining relations are allowed:
//                                                           O 
// |=|=|   |=|=|   |=|=|   O           O                   |=|=|
// | | O   O | |   O | O   | O       O |     O             O   O
// | O       O |     O     | | O   O | |   O | O   O   O
// O           O           |=|=|   |=|=|   |=|=|   |=|=|
//                                                   O
// If this is unavoidable as a result of a pin constraint or
// combination of via constraints, then we need to push the pins
// away from eachother.
//
// |==|==|    O     O
// |  O  |    |  O  |
// O     O    |==|==|
//
// Or go back and look for a new placement.
struct ViaConstraint {
	ViaConstraint();
	ViaConstraint(Index idx);
	~ViaConstraint();

	// After we have resolved all of the pin constraint cycles, we
	// check for cycles introduced by via constraints. These can't be
	// broken by breaking up the routes because all you'll do is add a
	// new via without actually satisfying the via constraint.
	//
	// =|=|=|=|
	// -|-O | | <-- breaking the route won't remove this via
	//  O | O | <-- it just creates more violations
	//    O---O
	//
	// So instead, when we encounter a cycle created by via
	// constraints, we need to add spacing between the pins.
	//
	// =|==|==|=|
	// -|--O--|-O
	//  O     O 
	//
	// TODO(edward.bingham) One caveat, if breaking the route allows
	// us to route over the cell, and doesn't create more violations,
	// then it can fix the cycle.
	//
	// ---O
	// =|=|=|
	//  O | O
	//    O--

	struct Pin {
		// index to the pin in this constraint
		Index idx;
		// horizontal offset between the previous pin's gate and this pin's via to the route
		int off;
	};

	// index into Router::stack
	Index idx;
	array<vector<ViaConstraint::Pin>, 2> side;
};

// DESIGN(edward.bingham) If two routes are on the same layer, then
// there must be an ordering between them. One must be below the
// other.
//
// O----O----O--O
// | O--|--O |  |
// |=|==|==|=|==|
//
//    OR
//
//   O-----O
// O-|--O--|-O--O
// |=|==|==|=|==|
//
// So, route constraints are initialized with the constraint
// direction unassigned (select=-1), but with the spacing information
// (off) precomputed using our DRC engine (ruler). We then use a
// greedy algorithm to determine a reasonable ordering for these
// constraints within the bounds of the pin and via constraints. See
// Router::assignRouteConstraints for more information about this
// process.
struct RouteConstraint {
	RouteConstraint();
	RouteConstraint(int a, int b, int off0=0, int off1=0, int select=-1);
	~RouteConstraint();

	// index into Router::wires
	array<int, 2> wires;

	// derived by Router::solve
	// from = this->wires[select], to = this->wires[1-select]
	int select;

	// pre-computed spacing information. This is the offset from one
	// Wire::layout's origin to the other Wire::layout's origin along
	// the vertical axis
	array<int, 2> off;
};

bool operator==(const RouteConstraint &c0, const RouteConstraint &c1);
bool operator<(const RouteConstraint &c0, const RouteConstraint &c1);

struct RouteGroupConstraint {
	RouteGroupConstraint();
	RouteGroupConstraint(int wire, Index pin);
	~RouteGroupConstraint();

	int wire;
	Index pin;
};

struct Router {
	Router(const Tech &tech, const Placement &place, bool progress=false, bool debug=false);
	~Router();

	bool progress;
	bool debug;

	const Tech *tech;
	const Subckt *ckt;

	bool allowOverCell;

	// Computed by the placement system
	// stack[0] is Model::NMOS
	// stack[1] is Model::PMOS
	// stack[2] is used for virtual pins that facilitate dogleg routing
	array<Stack, 3> stack;
	vector<Wire> routes;

	// channel routing constraint graph
	vector<PinConstraint> pinConstraints;
	vector<RouteConstraint> routeConstraints;
	vector<ViaConstraint> viaConstraints;
	vector<RouteGroupConstraint> groupConstraints;

	int cellHeight;
	int cycleCount;
	int cost;

	const Pin &pin(Index i) const;
	Pin &pin(Index i);

	int pinWidth(Index i) const;
	int pinHeight(Index i) const;
	
	// Finish building the constraint graph, filling out vcon and hcon.
	void delRoute(int route);
	void buildPinConstraints(int level=1, bool reset=false);
	void buildViaConstraints();
	void buildRoutes();
	bool findCycles(vector<vector<int> > &cycles);
	bool breakRoute(int route, set<int> cycleRoutes);
	bool breakCycles(vector<vector<int> > cycles);
	bool findAndBreakPinCycles();
	void findAndBreakViaCycles();
	void alignVirtualPins();
	void addIOPins();
	void buildPins();
	void buildContacts();
	void buildHorizConstraints(bool reset=false);
	void updatePinPos(bool reset=false);
	int alignPins(int maxDist = -1);
	void drawRoutes();
	vector<RouteConstraint> createRouteConstraint(int i, int j);
	void buildRouteConstraints(bool reset=false);
	void buildGroupConstraints();
	set<int> propagateRouteConstraint(int idx);
	vector<int> findTop();
	vector<int> findBottom();
	void zeroWeights();
	void clearPrev();
	bool resetGraph();
	bool buildPrevNodes(vector<int> start=vector<int>());
	void buildPinBounds(bool reset=false);
	bool buildPOffsets(vector<int> start=vector<int>());
	bool buildNOffsets(vector<int> start=vector<int>());
	bool assignRouteConstraints(bool reset=true);
	void lowerRoutes(int window=0);
	int computeCost();

	// Solve the constraint and circuit graph, filling out layers and constraints
	void load(const Placement &place);
	bool solve();

	// Print the solution description
	void print();
};

}
